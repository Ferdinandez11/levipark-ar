<script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        // üî• AR: Importamos el bot√≥n de Realidad Aumentada
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        // ======================================================================
        // BASE DE DATOS (IGUAL QUE ANTES)
        // ======================================================================
        const productsDB = {
            "L√≠nea Cl√°sica": {
                "Torres": [
                    { name: "Torre Peque√±a", file: "tobogan.glb", price: 2500 },
                    { name: "Castillo", file: "tobogan.glb", price: 5000 }
                ],
                "Columpios": [
                    { name: "Columpio Doble", file: "columpio.glb", price: 1200 }
                ],
                "Muelles": [
                    { name: "Muelle Caballo", file: "muelle.glb", price: 450 }
                ]
            },
            "L√≠nea Futura": {
                "Estructuras": [
                    { name: "Cubo Escalada", file: "tobogan.glb", price: 6000 },
                    { name: "Red Ara√±a", file: "columpio.glb", price: 3000 }
                ]
            },
            "Mobiliario": {
                "Bancos": [
                    { name: "Banco Madera", file: "banco.glb", price: 300 }
                ]
            }
        };

        let scene, renderer, controls;
        let perspectiveCamera, orthoCamera, activeCamera; 
        let plane, raycaster, pointer, gridHelper;
        let dirLight, hemiLight;
        let sunAzimuth = 45, sunElevation = 45;

        let productToPlace = null, productPrice = 0;      
        let selectedObject = null, isDragging = false; 
        let totalPrice = 0;
        let dragStartPosition = new THREE.Vector3(); 
        let isColliding = false; 

        const objectsInScene = []; 
        let selectionBox; 
        const loader = new GLTFLoader();

        // üî• AR: Grupo contenedor para mover todo el parque junto en AR si hace falta
        let parkGroup; 

        init();
        initCatalog(); 
        setupEventListeners(); 
        // üî• AR: Ya no llamamos a animate() aqu√≠ directamente, lo hace el renderer
    
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            
            // üî• AR: Crear un grupo contenedor. Pondremos los objetos AQU√ç, no directamente en scene
            parkGroup = new THREE.Group();
            scene.add(parkGroup);

            perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            perspectiveCamera.position.set(10, 10, 10); // Un poco m√°s cerca para AR

            const aspect = window.innerWidth / window.innerHeight;
            const d = 20; 
            orthoCamera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            orthoCamera.position.set(20, 20, 20); 

            activeCamera = perspectiveCamera;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
            renderer.outputColorSpace = THREE.SRGBColorSpace; 
            
            // üî• AR: Habilitar WebXR
            renderer.xr.enabled = true; 
            document.body.appendChild(renderer.domElement);

            // üî• AR: A√±adir bot√≥n de AR con soporte para que la UI se vea encima (domOverlay)
            const arButton = ARButton.createButton(renderer, { 
                requiredFeatures: ['hit-test'], 
                optionalFeatures: ['dom-overlay'], 
                domOverlay: { root: document.body } 
            });
            document.body.appendChild(arButton);

            hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
            scene.add(hemiLight);

            dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.castShadow = true;
            dirLight.position.set(10, 20, 10); // Ajustado para mejor sombra en AR
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            scene.add(dirLight);
            
            // üî• AR: El suelo para escritorio (verde). 
            // En AR, idealmente deber√≠amos hacerlo transparente pero que reciba sombras.
            const geometry = new THREE.PlaneGeometry(100, 100);
            const material = new THREE.MeshStandardMaterial({ color: 0x55aa55, roughness: 0.8 });
            plane = new THREE.Mesh(geometry, material);
            plane.rotation.x = -Math.PI / 2;
            plane.receiveShadow = true;
            scene.add(plane); // El plano base sigue en la escena ra√≠z para referencias

            gridHelper = new THREE.GridHelper(100, 100, 0xffffff, 0xcccccc);
            scene.add(gridHelper);

            selectionBox = new THREE.BoxHelper(undefined, 0xffff00);
            scene.add(selectionBox);
            selectionBox.visible = false;

            controls = new OrbitControls(activeCamera, renderer.domElement);
            controls.enableDamping = true; 
            
            raycaster = new THREE.Raycaster();
            pointer = new THREE.Vector2();
            
            window.addEventListener('resize', onWindowResize);

            // üî• AR: Iniciar el bucle de renderizado compatible con XR
            renderer.setAnimationLoop(render);
        }

        // --- (Toda la parte de initCatalog y renderCategories es IGUAL) ---
        function initCatalog() {
            const select = document.getElementById('line-select');
            select.innerHTML = "";
            const lines = Object.keys(productsDB);
            if (lines.length === 0) return;
            lines.forEach(line => {
                const option = document.createElement('option');
                option.value = line; option.innerText = line; select.appendChild(option);
            });
            select.addEventListener('change', (e) => renderCategories(e.target.value));
            renderCategories(lines[0]);
        }

        function renderCategories(lineName) {
            const container = document.getElementById('dynamic-catalog');
            container.innerHTML = ""; 
            if (!productsDB[lineName]) return;
            const categories = productsDB[lineName];

            for (const [categoryName, products] of Object.entries(categories)) {
                const accBtn = document.createElement('button');
                accBtn.className = "accordion-btn";
                accBtn.innerText = categoryName;
                
                const panel = document.createElement('div');
                panel.className = "panel-products";

                if (Array.isArray(products)) {
                    products.forEach(prod => {
                        const btn = document.createElement('button');
                        btn.className = "btn-product";
                        btn.innerHTML = `${prod.name} <span style="float:right; opacity:0.7">${prod.price}‚Ç¨</span>`;
                        btn.addEventListener('click', function() { prepareToPlace(prod.file, prod.price, this); });
                        panel.appendChild(btn);
                    });
                }
                accBtn.addEventListener("click", function() {
                    this.classList.toggle("active-acc");
                    if (panel.style.maxHeight) panel.style.maxHeight = null; else panel.style.maxHeight = panel.scrollHeight + "px";
                });
                container.appendChild(accBtn); container.appendChild(panel);
            }
        }

        function setupEventListeners() {
            // Eventos de puntero
            window.addEventListener('pointerdown', onPointerDown);
            window.addEventListener('pointermove', onPointerMove);
            window.addEventListener('pointerup', onPointerUp);
            window.addEventListener('keydown', onKeyDown);

            // --- (Resto de listeners IGUALES) ---
            document.getElementById('btn-toggle-env').addEventListener('click', () => {
                const p = document.getElementById('env-panel'); p.style.display = p.style.display === 'block' ? 'none' : 'block';
            });
            document.getElementById('bg-day').addEventListener('click', () => setSky('day'));
            document.getElementById('bg-sunset').addEventListener('click', () => setSky('sunset'));
            document.getElementById('bg-night').addEventListener('click', () => setSky('night'));
            document.getElementById('bg-white').addEventListener('click', () => setSky('white'));
            
            document.getElementById('sun-azimuth').addEventListener('input', (e) => updateSun(e.target.value, 'azimuth'));
            document.getElementById('sun-elevation').addEventListener('input', (e) => updateSun(e.target.value, 'elevation'));
            document.getElementById('light-intensity').addEventListener('input', (e) => { dirLight.intensity = parseFloat(e.target.value); });

            document.getElementById('btn-projection').addEventListener('click', toggleProjection);
            document.getElementById('view-iso').addEventListener('click', () => setView('iso'));
            document.getElementById('view-top').addEventListener('click', () => setView('top'));
            document.getElementById('view-front').addEventListener('click', () => setView('front'));
            document.getElementById('btn-reset').addEventListener('click', resetScene);

            document.getElementById('btn-lock').addEventListener('click', toggleLock);
            document.getElementById('btn-collision').addEventListener('click', toggleObjectCollision);
            
            document.getElementById('rot-y-n').addEventListener('click', () => rotateSelected('y', -45));
            document.getElementById('rot-y-p').addEventListener('click', () => rotateSelected('y', 45));
            document.getElementById('rot-x-n').addEventListener('click', () => rotateSelected('x', -15));
            document.getElementById('rot-x-p').addEventListener('click', () => rotateSelected('x', 15));
            document.getElementById('rot-z-n').addEventListener('click', () => rotateSelected('z', -15));
            document.getElementById('rot-z-p').addEventListener('click', () => rotateSelected('z', 15));
            
            document.getElementById('reset-rot').addEventListener('click', resetRotation);
            document.getElementById('move-down').addEventListener('click', () => moveVertical(-0.1));
            document.getElementById('move-up').addEventListener('click', () => moveVertical(0.1));
            document.getElementById('reset-height').addEventListener('click', resetHeight);
            document.getElementById('btn-delete').addEventListener('click', deleteSelected);
        }

        function setSky(type) {
            let color, fogColor, groundColor, showGrid = true;
            if (type === 'day') { color=0x87CEEB; fogColor=0x87CEEB; groundColor=0x55aa55; dirLight.color.setHex(0xffffff); }
            else if (type === 'sunset') { color=0xff9966; fogColor=0xff9966; groundColor=0x6b4f3b; dirLight.color.setHex(0xffaa00); }
            else if (type === 'night') { color=0x111111; fogColor=0x111111; groundColor=0x223322; dirLight.color.setHex(0xaaccff); }
            else if (type === 'white') { color=0xffffff; fogColor=0xffffff; groundColor=0xffffff; dirLight.color.setHex(0xffffff); showGrid=false; }
            scene.background = new THREE.Color(color); 
            // üî• AR: En AR queremos el fondo transparente para ver la c√°mara
            if(renderer.xr.isPresenting) scene.background = null;

            scene.fog.color.setHex(fogColor);
            plane.material.color.setHex(groundColor); gridHelper.visible = showGrid;
        }

        // --- (Funciones de Sol IGUALES) ---
        function updateSun(val, type) {
            if (type === 'azimuth') sunAzimuth = val; if (type === 'elevation') sunElevation = val;
            updateSunPosition();
        }
        function updateSunPosition() {
            const phi = (90 - sunElevation) * (Math.PI / 180); const theta = sunAzimuth * (Math.PI / 180);
            dirLight.position.setFromSphericalCoords(50, phi, theta);
        }

        function prepareToPlace(file, price, btn) {
            if (productToPlace === file) { productToPlace = null; document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active')); return; }
            deselectObject(); productToPlace = file; productPrice = price;
            document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active')); btn.classList.add('active');
        }

        function onPointerDown(event) {
            if (event.target.closest('#ui-panel') || event.target.closest('#edit-panel') || event.target.closest('#env-panel')) return;
            
            // L√≥gica normal de escritorio
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, activeCamera); 
            
            if (productToPlace) {
                const intersects = raycaster.intersectObject(plane);
                if (intersects.length > 0) placeObject(intersects[0].point);
                return;
            }
            const intersectsObjects = raycaster.intersectObjects(objectsInScene, true);
            if (intersectsObjects.length > 0) {
                let selected = intersectsObjects[0].object;
                while (selected.parent && !objectsInScene.includes(selected)) selected = selected.parent;
                if (objectsInScene.includes(selected)) {
                    selectObject(selected);
                    if (!selected.userData.locked) {
                        isDragging = true; controls.enabled = false; document.body.style.cursor = 'grabbing';
                        dragStartPosition.copy(selected.position);
                    }
                }
            } else { deselectObject(); }
        }

        function placeObject(pos) {
            document.getElementById('loading').style.display = 'block';
            loader.load(productToPlace, (gltf) => {
                const model = gltf.scene;
                model.traverse(n => { if(n.isMesh) { n.castShadow=true; n.receiveShadow=true; } });
                
                // Si estamos en AR, quiz√°s la escala sea diferente, pero asumimos 1:1 por ahora
                model.position.set(pos.x, 0, pos.z);
                model.userData = { price: productPrice, locked: false, collides: true };
                
                // üî• AR: A√±adimos a parkGroup en lugar de scene directamente si queremos agrupar
                // Pero tu l√≥gica actual usa arrays, as√≠ que mantendremos scene para no romper selecci√≥n
                scene.add(model); 
                objectsInScene.push(model); totalPrice += productPrice; updateBudget();
                selectObject(model); document.getElementById('loading').style.display = 'none';
                productToPlace = null; document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active'));
            }, undefined, (err) => { console.error(err); alert("Error cargando modelo"); document.getElementById('loading').style.display = 'none'; });
        }

        function onPointerMove(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(pointer, activeCamera); 
            if (isDragging && selectedObject && !selectedObject.userData.locked) {
                const intersects = raycaster.intersectObject(plane);
                if (intersects.length > 0) {
                    selectedObject.position.x = intersects[0].point.x; selectedObject.position.z = intersects[0].point.z;
                    selectionBox.update(); checkCollisions();
                }
            }
        }
        function onPointerUp() {
            if (isDragging) {
                if (isColliding && selectedObject.userData.collides) {
                    selectedObject.position.copy(dragStartPosition); selectionBox.update(); isColliding = false; checkCollisions();
                }
                isDragging = false; controls.enabled = true; document.body.style.cursor = 'default';
            }
        }

        // --- (Funciones de Selecci√≥n, UI y Colisi√≥n IGUALES) ---
        function selectObject(obj) {
            selectedObject = obj; selectionBox.setFromObject(obj); selectionBox.visible = true;
            document.getElementById('edit-panel').style.display = 'block'; updateUI();
        }
        function deselectObject() { selectedObject = null; selectionBox.visible = false; document.getElementById('edit-panel').style.display = 'none'; }
        
        function updateUI() {
            if (!selectedObject) return;
            const btnLock = document.getElementById('btn-lock'); const btnCol = document.getElementById('btn-collision');
            if (selectedObject.userData.locked) { btnLock.innerText = "üîí Desbloquear"; btnLock.classList.add('is-locked'); selectionBox.material.color.setHex(0xff4444); } 
            else { btnLock.innerText = "üîì Fijar"; btnLock.classList.remove('is-locked'); selectionBox.material.color.setHex(0xffff00); }
            if (selectedObject.userData.collides) { btnCol.innerText = "üí• Colisi√≥n: ON"; btnCol.classList.remove('is-inactive'); } 
            else { btnCol.innerText = "üëª Fantasma"; btnCol.classList.add('is-inactive'); }
        }
        function toggleLock() { if(selectedObject) { selectedObject.userData.locked = !selectedObject.userData.locked; updateUI(); } }
        function toggleObjectCollision() { if(selectedObject) { selectedObject.userData.collides = !selectedObject.userData.collides; updateUI(); } }

        function checkCollisions() {
            if (!selectedObject || !selectedObject.userData.collides) { isColliding=false; return; }
            const box = new THREE.Box3().setFromObject(selectedObject).expandByScalar(-0.1); let hit = false;
            for (let other of objectsInScene) {
                if (other !== selectedObject && other.userData.collides) {
                    if (box.intersectsBox(new THREE.Box3().setFromObject(other).expandByScalar(-0.1))) { hit = true; break; }
                }
            }
            isColliding = hit; selectionBox.material.color.setHex(isColliding ? 0xffa500 : 0xffff00);
            if (!isColliding) updateUI();
        }

        function rotateSelected(axis, deg) { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.rotation[axis] += deg * (Math.PI/180); selectionBox.update(); checkCollisions(); }
        function resetRotation() { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.rotation.set(0,0,0); selectionBox.update(); }
        function moveVertical(amount) { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.position.y += amount; selectionBox.update(); }
        function resetHeight() { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.position.y = 0; selectionBox.update(); }
        function deleteSelected() { 
            if(!selectedObject || selectedObject.userData.locked) return; 
            scene.remove(selectedObject); objectsInScene.splice(objectsInScene.indexOf(selectedObject), 1);
            totalPrice -= selectedObject.userData.price; updateBudget(); deselectObject();
        }
        function resetScene() { objectsInScene.forEach(o => scene.remove(o)); objectsInScene.length=0; totalPrice=0; updateBudget(); deselectObject(); }
        function updateBudget() { document.getElementById('budget-box').innerText = totalPrice.toLocaleString('es-ES') + " ‚Ç¨"; }
        function toggleProjection() {
            const btn = document.getElementById('btn-projection'); const prevPos = activeCamera.position.clone(); const prevTarget = controls.target.clone();
            if (activeCamera === perspectiveCamera) { activeCamera = orthoCamera; btn.innerText = "üìê Ortogr√°fica"; btn.style.background = "#555"; } 
            else { activeCamera = perspectiveCamera; btn.innerText = "üëÅÔ∏è Perspectiva"; btn.style.background = "#4a90e2"; }
            activeCamera.position.copy(prevPos); activeCamera.lookAt(prevTarget); controls.object = activeCamera; controls.update();
        }
        function setView(type) {
            controls.target.set(0,0,0);
            if(type==='iso') activeCamera.position.set(15,15,15); if(type==='top') activeCamera.position.set(0,20,0); if(type==='front') activeCamera.position.set(0,0,20);
            activeCamera.lookAt(0,0,0); controls.update();
        }
        function onKeyDown(e) { if(e.key === 'Delete') deleteSelected(); }
        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight; perspectiveCamera.aspect = aspect; perspectiveCamera.updateProjectionMatrix();
            orthoCamera.left = -20 * aspect; orthoCamera.right = 20 * aspect; orthoCamera.top = 20; orthoCamera.bottom = -20; orthoCamera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        // üî• AR: Bucle de animaci√≥n nuevo para WebXR
        function render() {
            // Cuando estamos en AR, el background debe ser nulo para ver la c√°mara
            if (renderer.xr.isPresenting) {
                scene.background = null;
                gridHelper.visible = false; // Ocultamos la rejilla en AR si molesta
                plane.visible = false;      // Ocultamos el suelo verde en AR
            } else {
                // Restaurar visibilidad al salir de AR
                gridHelper.visible = true;
                plane.visible = true;
            }

            controls.update();
            renderer.render(scene, activeCamera);
        }
    </script>
