<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Levipark AR - v26 Floor Transform</title>
    <style>
        /* ESTILOS GENERALES */
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; user-select: none; background: #222; }
        
        /* PANELES */
        #ui-panel, #edit-panel, #env-panel, #floor-input-panel {
            background: rgba(30, 30, 30, 0.95); 
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: #fff;
            padding: 15px;
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            transition: opacity 0.3s, transform 0.3s;
        }

        #ui-panel { position: absolute; top: 20px; left: 20px; width: 280px; max-height: 75vh; overflow-y: auto; z-index: 10; display: none; }
        #floor-input-panel { position: absolute; top: 20px; left: 50%; transform: translateX(-50%); width: 280px; z-index: 20; display: none; text-align: center; }
        /* Panel de edici√≥n un poco m√°s alto para que quepan todos los controles */
        #edit-panel { display: none; position: absolute; top: 20px; right: 20px; width: 200px; max-height: 80vh; overflow-y: auto; z-index: 10; }
        #env-panel { display: none; position: absolute; bottom: 80px; left: 20px; width: 240px; z-index: 10; }

        /* BOTONES FLOTANTES */
        #btn-toggle-menu, #btn-toggle-env {
            position: absolute; left: 20px;
            background: #4a90e2; color: white; border: 1px solid #fff;
            width: 45px; height: 45px; border-radius: 50%;
            display: flex; align-items: center; justify-content: center;
            font-size: 20px; cursor: pointer; z-index: 100;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5);
        }
        #btn-toggle-menu { top: 20px; }
        #btn-toggle-env { bottom: 20px; background: #333; border-color: #555; }

        /* UI ELEMENTS */
        .accordion-btn { background-color: #444; color: #fff; cursor: pointer; padding: 10px; width: 100%; border: 1px solid #555; text-align: left; outline: none; font-size: 13px; margin-top: 5px; border-radius: 4px; display: flex; justify-content: space-between; }
        .accordion-btn:hover { background-color: #555; } .accordion-btn:after { content: '+'; font-weight: bold; } .accordion-btn.active-acc:after { content: "-"; }
        .panel-products { padding: 0 5px; background-color: rgba(0,0,0,0.3); max-height: 0; overflow: hidden; transition: max-height 0.2s ease-out; margin-bottom: 5px; }
        .line-selector { width: 100%; padding: 8px; background: #222; color: #fff; border: 1px solid #4a90e2; border-radius: 6px; margin-bottom: 10px; font-size: 13px; cursor: pointer; }
        .btn-product { display: block; width: 100%; padding: 8px; margin: 4px 0; border: 1px solid rgba(255,255,255,0.1); background: rgba(255,255,255,0.05); cursor: pointer; text-align: left; border-radius: 4px; color: #ccc; font-size: 12px; }
        .btn-product:hover { background: #4a90e2; color: white; } .btn-product.active { background: #4a90e2; border-color: #fff; color: white; font-weight: bold; }
        
        h1 { font-size: 16px; margin-top: 0; color: #fff; border-bottom: 1px solid rgba(255,255,255,0.2); padding-bottom: 8px; display: flex; justify-content: space-between; align-items: center; }
        h2 { font-size: 12px; margin: 10px 0 5px 0; color: #aaa; text-transform: uppercase; }
        button { font-family: inherit; transition: all 0.2s; outline: none; }
        
        .views-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 5px; margin-bottom: 10px; }
        .btn-view { padding: 8px; font-size: 11px; cursor: pointer; background: #333; border: 1px solid #555; color: #ddd; border-radius: 4px; }
        .tools-grid { display: flex; gap: 5px; margin-bottom: 15px; }
        .btn-tool { flex: 1; padding: 10px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; color: white; font-size: 12px; }
        #btn-measure { background: #e67e22; } #btn-measure.active-tool { background: #d35400; border: 2px solid white; }
        #btn-floor { background: #9b59b6; } #btn-floor.active-tool { background: #8e44ad; border: 2px solid white; }
        .projection-toggle { width: 100%; margin-bottom: 10px; padding: 8px; cursor: pointer; background: #4a90e2; color: white; border: none; border-radius: 6px; font-size: 12px; }
        
        .control-row { display: flex; align-items: center; justify-content: space-between; margin-bottom: 5px; }
        .btn-mini { flex: 1; margin: 0 2px; padding: 8px; cursor: pointer; border: none; background: #444; color: #ccc; border-radius: 4px; font-size: 12px; }
        .btn-action { width: 100%; padding: 8px; cursor: pointer; border: none; background: #444; color: white; border-radius: 6px; margin-top:5px; font-size: 12px; }
        .btn-delete { background: #d9534f; }
        .status-btn { font-weight: bold; margin-bottom: 8px; border: none; width: 100%; padding: 8px; cursor: pointer; border-radius: 6px; font-size: 12px; }
        #btn-lock { background: #555; } #btn-lock.is-locked { background: #d9534f; }
        #btn-collision { background: #28a745; } #btn-collision.is-inactive { background: #555; }
        .panel-header-btn { background: none; border: none; color: #aaa; cursor: pointer; font-size: 18px; padding: 0 5px; }
        #budget-box { margin-top: 15px; border-top: 1px solid #555; padding-top: 10px; font-size: 20px; font-weight: bold; color: #4cd137; text-align: right; }
        #loading { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 1000; }
        
        .bg-options { display: flex; gap: 5px; margin-bottom: 10px; }
        .bg-btn { flex: 1; height: 30px; border-radius: 4px; border: 1px solid #555; cursor: pointer; }
        .bg-white { background: #ffffff; } .bg-green { background: #2ecc71; } .bg-blue { background: #3498db; } .bg-yellow { background: #f1c40f; }

        /* INPUTS */
        .input-row { display: flex; gap: 5px; margin-bottom: 8px; }
        .input-box { flex: 1; background: #222; border: 1px solid #555; color: white; padding: 8px; border-radius: 4px; width: 100%; box-sizing: border-box; font-size:14px; }
        .input-box:focus { border-color: #9b59b6; outline: none; background: #333; }
        .input-label { font-size: 10px; color: #aaa; display: block; text-align: left; margin-bottom: 2px; }
        #btn-add-point { background: #9b59b6; width: 100%; color: white; border: none; padding: 10px; border-radius: 4px; cursor: pointer; font-weight:bold; }
        
        .floor-colors-grid { display: flex; gap: 5px; margin-bottom: 10px; }
        .f-col-btn { flex: 1; height: 35px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.2); cursor: pointer; }
        .f-garnet { background: #A04040; } .f-blue { background: #2980b9; } .f-green { background: #27ae60; } .f-black { background: #2c3e50; }

        @media (max-width: 600px) {
            #ui-panel { top: 75px; left: 10px; right: 10px; width: auto; max-height: 60vh; }
            #edit-panel { top: 75px; right: 10px; width: 180px; }
            #btn-toggle-menu { width: 40px; height: 40px; font-size: 18px; top: 15px; left: 15px; }
            #btn-toggle-env { width: 40px; height: 40px; font-size: 18px; bottom: 15px; left: 15px; }
            #floor-input-panel { top: 15px; width: 90%; }
        }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

    <div id="loading">üì¶ Cargando...</div>
    <div id="btn-toggle-menu">‚ò∞</div>
    <div id="btn-toggle-env">‚òÄ</div> 

    <!-- AMBIENTE -->
    <div id="env-panel">
        <h1>Fondo</h1>
        <div class="bg-options">
            <button class="bg-btn bg-white" id="bg-white" title="Blanco"></button>
            <button class="bg-btn bg-green" id="bg-green" title="Verde"></button>
            <button class="bg-btn bg-blue" id="bg-blue" title="Azul"></button>
            <button class="bg-btn bg-yellow" id="bg-yellow" title="Amarillo"></button>
        </div>
        <p style="font-size:11px; margin-bottom:5px; margin-top:15px">Posici√≥n Sol</p>
        <input type="range" min="0" max="360" value="45" id="sun-azimuth">
        <input type="range" min="0" max="90" value="45" id="sun-elevation">
        <p style="font-size:11px; margin-bottom:5px">Intensidad Luz</p>
        <input type="range" min="0" max="3" step="0.1" value="1.5" id="light-intensity">
    </div>

    <!-- PANEL INPUT SUELO -->
    <div id="floor-input-panel">
        <h1 style="justify-content:center">‚úèÔ∏è Dibujando Suelo</h1>
        <p style="font-size:11px; color:#aaa; margin-top:-5px">Escribe para fijar medidas</p>
        <div class="input-row">
            <div style="flex:1">
                <span class="input-label">Distancia (m)</span>
                <input type="number" id="inp-dist" class="input-box" step="0.5" placeholder="Rat√≥n...">
            </div>
            <div style="flex:1">
                <span class="input-label">√Ångulo (¬∫)</span>
                <input type="number" id="inp-ang" class="input-box" step="15" placeholder="Rat√≥n...">
            </div>
        </div>
        <button id="btn-add-point">‚ûï A√±adir Punto</button>
        <button id="btn-close-floor" style="margin-top:5px; background:#27ae60; width:100%; border:none; padding:10px; border-radius:4px; color:white; display:none; font-weight:bold;">‚úÖ Terminar</button>
    </div>

    <!-- PANEL PRINCIPAL -->
    <div id="ui-panel">
        <h1>LEVIPARK AR <button class="panel-header-btn" id="btn-close-menu">√ó</button></h1>
        
        <button class="projection-toggle" id="btn-projection">üëÅÔ∏è Perspectiva</button>
        
        <div class="views-grid">
            <button class="btn-view" id="view-iso">üì¶ Iso</button>
            <button class="btn-view" id="view-top">üìê Planta</button>
            <button class="btn-view" id="view-front">üìè Alzado</button>
            <button class="btn-view" id="view-side">ü•¥ Perfil</button>
        </div>
        
        <!-- HERRAMIENTAS -->
        <div class="tools-grid">
            <button id="btn-measure" class="btn-tool">üìè Medir</button>
            <button id="btn-floor" class="btn-tool">‚úèÔ∏è Suelo</button>
        </div>

        <h2>Cat√°logo</h2>
        <select id="line-select" class="line-selector"></select>
        <div id="dynamic-catalog"></div>

        <div id="budget-box">0 ‚Ç¨</div>
        <button id="btn-reset" style="margin-top:20px; width:100%; padding:10px; background:#444; color:#ccc; border:none; border-radius:6px; cursor:pointer;">‚ùå Borrar Todo</button>
    </div>

    <!-- PANEL EDICI√ìN -->
    <div id="edit-panel">
        <h1>Editar <button class="panel-header-btn" id="btn-min-edit">_</button></h1>
        <div id="edit-content">
            
            <!-- COM√öN PARA TODOS: FIJAR Y COLISI√ìN -->
            <button id="btn-lock" class="status-btn">üîì Fijar</button>
            <button id="btn-collision" class="status-btn edit-control">üí• Colisi√≥n: ON</button>

            <!-- CONTROLES EST√ÅNDAR (Visible para TODOS los objetos, incluido suelo) -->
            <div id="edit-standard">
                <h2>Rotaci√≥n</h2>
                <div class="control-row">
                    <span style="color:#4cd137; font-weight:bold;">Y</span>
                    <button class="btn-mini edit-control" id="rot-y-n">‚ü≤</button>
                    <button class="btn-mini edit-control" id="rot-y-p">‚ü≥</button>
                </div>
                <div class="control-row">
                    <span style="color:#e84118; font-weight:bold;">X</span>
                    <button class="btn-mini edit-control" id="rot-x-n">‚ñº</button>
                    <button class="btn-mini edit-control" id="rot-x-p">‚ñ≤</button>
                </div>
                <div class="control-row">
                    <span style="color:#0097e6; font-weight:bold;">Z</span>
                    <button class="btn-mini edit-control" id="rot-z-n">‚óÄ</button>
                    <button class="btn-mini edit-control" id="rot-z-p">‚ñ∂</button>
                </div>
                <button class="btn-action edit-control" id="reset-rot">‚Ü∫ Reset</button>

                <h2>Posici√≥n</h2>
                <div class="control-row">
                    <button class="btn-mini edit-control" id="move-down">‚¨á</button>
                    <button class="btn-mini edit-control" id="move-up">‚¨Ü</button>
                </div>
                <button class="btn-action edit-control" id="reset-height">‚≠± Suelo</button>
            </div>

            <!-- SOLO PARA SUELO (Se muestra DEBAJO de lo est√°ndar) -->
            <div id="edit-floor-specific" style="display:none; margin-top:15px; border-top:1px solid #555; padding-top:10px;">
                <h2>Color Suelo</h2>
                <div class="floor-colors-grid">
                    <button class="f-col-btn f-garnet" id="fc-garnet" title="Granate"></button>
                    <button class="f-col-btn f-blue" id="fc-blue" title="Azul"></button>
                    <button class="f-col-btn f-green" id="fc-green" title="Verde"></button>
                    <button class="f-col-btn f-black" id="fc-black" title="Negro"></button>
                </div>
                <p style="font-size:10px; color:#aaa; margin-top:10px; text-align:center;">
                    Valor Suelo: <span style="color:#fff; font-weight:bold;" id="floor-price-display">--</span> ‚Ç¨
                </p>
            </div>

            <button class="btn-action btn-delete edit-control" id="btn-delete" style="margin-top:15px">üóëÔ∏è Eliminar</button>
        </div>
    </div>

    <!-- SCRIPT -->
    <script>window.onerror=function(m,u,l){alert("Err:"+m+"\nL:"+l);return false;};</script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { ARButton } from 'three/addons/webxr/ARButton.js';

        try {
            // CONFIG
            const ENV_COLORS = { white: 0xffffff, green: 0x2ecc71, blue: 0x3498db, yellow: 0xf1c40f };
            const FLOOR_COLORS = { garnet: 0xA04040, blue: 0x2980b9, green: 0x27ae60, black: 0x2c3e50 };
            const PRICE_PER_M2 = 40; 

            const productsDB = {
                "L√≠nea Cl√°sica": {
                    "Torres": [ { name: "Torre Peque√±a", file: "tobogan.glb", price: 2500 }, { name: "Castillo", file: "tobogan.glb", price: 5000 } ],
                    "Columpios": [ { name: "Columpio Doble", file: "columpio.glb", price: 1200 } ],
                    "Muelles": [ { name: "Muelle Caballo", file: "muelle.glb", price: 450 } ]
                },
                "L√≠nea Futura": {
                    "Estructuras": [ { name: "Cubo Escalada", file: "tobogan.glb", price: 6000 }, { name: "Red Ara√±a", file: "columpio.glb", price: 3000 } ]
                },
                "Mobiliario": {
                    "Bancos": [ { name: "Banco Madera", file: "banco.glb", price: 300 } ]
                }
            };

            let scene, renderer, controls;
            let perspectiveCamera, orthoCamera, activeCamera; 
            let plane, raycaster, pointer = new THREE.Vector2(); 
            let dirLight, hemiLight;
            let sunAzimuth = 45, sunElevation = 45;
            let currentEnvColor = ENV_COLORS.white;

            let productToPlace = null, productPrice = 0;      
            let selectedObject = null, isDragging = false; 
            let totalPrice = 0;
            let dragStartPosition = new THREE.Vector3(); 
            let isColliding = false; 

            // TOOLS STATE
            let isMeasuring = false;
            let measurePoints = [], measureMarkers = [], measureLine = null, measureLabel = null;

            let isDrawingFloor = false;
            let floorPoints = [], floorMarkers = [], floorLine = null, floorLabel = null;
            let isInputFocused = false; 

            const objectsInScene = []; 
            let selectionBox; 
            const loader = new GLTFLoader();

            init();

            function init() {
                scene = new THREE.Scene();
                perspectiveCamera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
                perspectiveCamera.position.set(10, 10, 10);
                const aspect = window.innerWidth / window.innerHeight;
                const d = 20; 
                orthoCamera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
                orthoCamera.position.set(20, 20, 20); 
                activeCamera = perspectiveCamera;

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true }); 
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                renderer.shadowMap.type = THREE.PCFSoftShadowMap; 
                renderer.outputColorSpace = THREE.SRGBColorSpace; 
                renderer.xr.enabled = true; 
                document.body.appendChild(renderer.domElement);

                document.body.appendChild(ARButton.createButton(renderer, { 
                    requiredFeatures: ['hit-test'], optionalFeatures: ['dom-overlay'], domOverlay: { root: document.body } 
                }));

                hemiLight = new THREE.HemisphereLight(0xffffff, 0x444444, 1);
                scene.add(hemiLight);
                dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
                dirLight.castShadow = true;
                dirLight.position.set(10, 20, 10);
                dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048;
                scene.add(dirLight);

                const geometry = new THREE.PlaneGeometry(200, 200);
                const material = new THREE.MeshStandardMaterial({ color: ENV_COLORS.white, roughness: 1 });
                plane = new THREE.Mesh(geometry, material);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true;
                scene.add(plane);

                selectionBox = new THREE.BoxHelper(undefined, 0xffff00);
                scene.add(selectionBox);
                selectionBox.visible = false;

                controls = new OrbitControls(activeCamera, renderer.domElement);
                controls.enableDamping = true; 
                raycaster = new THREE.Raycaster();
                
                window.addEventListener('resize', onWindowResize);
                
                initCatalog(); 
                setupEventListeners();
                setEnvironmentColor(ENV_COLORS.white);

                renderer.setAnimationLoop(render);
            }

            function initCatalog() {
                const select = document.getElementById('line-select');
                if(!select) return;
                select.innerHTML = "";
                const lines = Object.keys(productsDB);
                if (lines.length === 0) return;
                lines.forEach(line => {
                    const option = document.createElement('option');
                    option.value = line; option.innerText = line; select.appendChild(option);
                });
                select.addEventListener('change', (e) => renderCategories(e.target.value));
                renderCategories(lines[0]);
            }

            function renderCategories(lineName) {
                const container = document.getElementById('dynamic-catalog');
                if(!container) return;
                container.innerHTML = ""; 
                if (!productsDB[lineName]) return;
                const categories = productsDB[lineName];
                for (const [categoryName, products] of Object.entries(categories)) {
                    const accBtn = document.createElement('button');
                    accBtn.className = "accordion-btn"; accBtn.innerText = categoryName;
                    const panel = document.createElement('div'); panel.className = "panel-products";
                    if (Array.isArray(products)) {
                        products.forEach(prod => {
                            const btn = document.createElement('button');
                            btn.className = "btn-product";
                            btn.innerHTML = `${prod.name} <span style="float:right; opacity:0.7">${prod.price}‚Ç¨</span>`;
                            btn.addEventListener('click', function() { 
                                prepareToPlace(prod.file, prod.price, this);
                                if(window.innerWidth < 600) document.getElementById('ui-panel').style.display = 'none';
                            });
                            panel.appendChild(btn);
                        });
                    }
                    accBtn.addEventListener("click", function() {
                        this.classList.toggle("active-acc");
                        if (panel.style.maxHeight) panel.style.maxHeight = null; else panel.style.maxHeight = panel.scrollHeight + "px";
                    });
                    container.appendChild(accBtn); container.appendChild(panel);
                }
            }

            function setupEventListeners() {
                window.addEventListener('pointerdown', onPointerDown);
                window.addEventListener('pointermove', onPointerMove);
                window.addEventListener('pointerup', onPointerUp);
                window.addEventListener('keydown', onKeyDown);

                const uiPanel = document.getElementById('ui-panel');
                document.getElementById('btn-toggle-menu').addEventListener('click', () => uiPanel.style.display = uiPanel.style.display === 'block' ? 'none' : 'block');
                document.getElementById('btn-close-menu').addEventListener('click', () => uiPanel.style.display = 'none');
                document.getElementById('btn-toggle-env').addEventListener('click', () => {
                    const p = document.getElementById('env-panel'); p.style.display = p.style.display === 'block' ? 'none' : 'block';
                });
                document.getElementById('btn-min-edit').addEventListener('click', () => {
                    const c = document.getElementById('edit-content'); c.style.display = c.style.display === 'none' ? 'block' : 'none';
                });

                const inputs = document.querySelectorAll('.input-box');
                inputs.forEach(input => {
                    input.addEventListener('focus', () => { isInputFocused = true; });
                    input.addEventListener('blur', () => { isInputFocused = false; });
                    input.addEventListener('input', updateFloorFromInput);
                });

                document.getElementById('bg-white').addEventListener('click', () => setEnvironmentColor(ENV_COLORS.white));
                document.getElementById('bg-green').addEventListener('click', () => setEnvironmentColor(ENV_COLORS.green));
                document.getElementById('bg-blue').addEventListener('click', () => setEnvironmentColor(ENV_COLORS.blue));
                document.getElementById('bg-yellow').addEventListener('click', () => setEnvironmentColor(ENV_COLORS.yellow));
                
                document.getElementById('sun-azimuth').addEventListener('input', (e) => updateSun(e.target.value, 'azimuth'));
                document.getElementById('sun-elevation').addEventListener('input', (e) => updateSun(e.target.value, 'elevation'));
                document.getElementById('light-intensity').addEventListener('input', (e) => { dirLight.intensity = parseFloat(e.target.value); });

                document.getElementById('btn-projection').addEventListener('click', toggleProjection);
                document.getElementById('view-iso').addEventListener('click', () => setView('iso'));
                document.getElementById('view-top').addEventListener('click', () => setView('top'));
                document.getElementById('view-front').addEventListener('click', () => setView('front'));
                document.getElementById('view-side').addEventListener('click', () => setView('side'));
                
                document.getElementById('btn-measure').addEventListener('click', toggleMeasureMode);
                document.getElementById('btn-floor').addEventListener('click', toggleFloorMode);
                document.getElementById('btn-add-point').addEventListener('click', addPointFromInput);
                document.getElementById('btn-close-floor').addEventListener('click', () => { finishFloor(); toggleFloorMode(); });
                
                document.getElementById('fc-garnet').addEventListener('click', () => setFloorColor(FLOOR_COLORS.garnet));
                document.getElementById('fc-blue').addEventListener('click', () => setFloorColor(FLOOR_COLORS.blue));
                document.getElementById('fc-green').addEventListener('click', () => setFloorColor(FLOOR_COLORS.green));
                document.getElementById('fc-black').addEventListener('click', () => setFloorColor(FLOOR_COLORS.black));

                document.getElementById('btn-reset').addEventListener('click', resetScene);
                document.getElementById('btn-lock').addEventListener('click', toggleLock);
                document.getElementById('btn-collision').addEventListener('click', toggleObjectCollision);
                
                document.getElementById('rot-y-n').addEventListener('click', () => rotateSelected('y', -45));
                document.getElementById('rot-y-p').addEventListener('click', () => rotateSelected('y', 45));
                document.getElementById('rot-x-n').addEventListener('click', () => rotateSelected('x', -15));
                document.getElementById('rot-x-p').addEventListener('click', () => rotateSelected('x', 15));
                document.getElementById('rot-z-n').addEventListener('click', () => rotateSelected('z', -15));
                document.getElementById('rot-z-p').addEventListener('click', () => rotateSelected('z', 15));
                
                document.getElementById('reset-rot').addEventListener('click', resetRotation);
                document.getElementById('move-down').addEventListener('click', () => moveVertical(-0.1));
                document.getElementById('move-up').addEventListener('click', () => moveVertical(0.1));
                document.getElementById('reset-height').addEventListener('click', resetHeight);
                document.getElementById('btn-delete').addEventListener('click', deleteSelected);
            }

            function setEnvironmentColor(colorHex) {
                currentEnvColor = colorHex;
                const color = new THREE.Color(colorHex);
                if (renderer && !renderer.xr.isPresenting) {
                    scene.background = color; scene.fog = new THREE.Fog(colorHex, 20, 100); 
                    if(plane) plane.material.color.setHex(colorHex); 
                }
            }
            function updateSun(val, type) {
                if (type === 'azimuth') sunAzimuth = val; if (type === 'elevation') sunElevation = val;
                const phi = (90 - sunElevation) * (Math.PI / 180); const theta = sunAzimuth * (Math.PI / 180);
                dirLight.position.setFromSphericalCoords(50, phi, theta);
            }

            function prepareToPlace(file, price, btn) {
                if(isMeasuring) toggleMeasureMode(); 
                if(isDrawingFloor) toggleFloorMode();
                if (productToPlace === file) { productToPlace = null; document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active')); return; }
                deselectObject(); productToPlace = file; productPrice = price;
                document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active')); btn.classList.add('active');
            }

            // --- MEDICI√ìN ---
            function toggleMeasureMode() {
                if(isDrawingFloor) toggleFloorMode();
                isMeasuring = !isMeasuring;
                const btn = document.getElementById('btn-measure');
                if(isMeasuring) {
                    btn.classList.add('active-tool'); btn.innerText = "üìè Click Punto A";
                    deselectObject(); productToPlace = null;
                    document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active'));
                } else {
                    btn.classList.remove('active-tool'); btn.innerText = "üìè Medir";
                    clearMeasurements();
                }
            }
            function clearMeasurements() {
                measurePoints = [];
                measureMarkers.forEach(m => scene.remove(m)); measureMarkers = [];
                if(measureLine) { scene.remove(measureLine); measureLine = null; }
                if(measureLabel) { scene.remove(measureLabel); measureLabel = null; }
            }
            function createMeasureMarker(pos) {
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(0.15,16,16), new THREE.MeshBasicMaterial({color: 0xe67e22, depthTest:false}));
                mesh.position.copy(pos); mesh.renderOrder = 999; scene.add(mesh); measureMarkers.push(mesh);
            }
            function updateMeasureLine(finalPos) {
                if(measurePoints.length < 1) return;
                const start = measurePoints[0];
                if(measureLine) scene.remove(measureLine);
                const geometry = new THREE.BufferGeometry().setFromPoints([start, finalPos]);
                measureLine = new THREE.Line(geometry, new THREE.LineBasicMaterial({ color: 0xe67e22, linewidth: 3, depthTest: false }));
                measureLine.renderOrder = 998; scene.add(measureLine);
                const dist = start.distanceTo(finalPos).toFixed(2);
                const btn = document.getElementById('btn-measure');
                if(isMeasuring && measurePoints.length === 1) btn.innerText = `üìè ${dist} m`;
                if(measurePoints.length === 2) {
                    createMeasureLabel(dist + " m", start.clone().lerp(finalPos, 0.5).add(new THREE.Vector3(0, 0.3, 0)));
                    btn.innerText = "üìè Terminar";
                }
            }
            function createMeasureLabel(text, pos) {
                if(measureLabel) scene.remove(measureLabel);
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                canvas.width = 256; canvas.height = 128;
                ctx.fillStyle = "rgba(0, 0, 0, 0.7)"; ctx.roundRect(10, 10, 236, 108, 20); ctx.fill();
                ctx.font = "bold 60px Arial"; ctx.fillStyle = "white"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(text, 128, 64);
                const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false });
                measureLabel = new THREE.Sprite(mat); measureLabel.position.copy(pos); measureLabel.scale.set(2, 1, 1); measureLabel.renderOrder = 999;
                scene.add(measureLabel);
            }

            // --- SUELO ---
            function toggleFloorMode() {
                if(isMeasuring) toggleMeasureMode();
                isDrawingFloor = !isDrawingFloor;
                const btn = document.getElementById('btn-floor');
                const panel = document.getElementById('floor-input-panel');
                if(isDrawingFloor) {
                    btn.classList.add('active-tool'); btn.innerText = "‚úèÔ∏è Cancelar";
                    panel.style.display = 'block';
                    deselectObject(); productToPlace = null;
                    document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active'));
                    document.getElementById('inp-dist').value = "";
                    document.getElementById('inp-ang').value = "";
                } else {
                    btn.classList.remove('active-tool'); btn.innerText = "‚úèÔ∏è Suelo";
                    panel.style.display = 'none';
                    clearFloorDraft();
                }
            }
            
            function clearFloorDraft() {
                floorPoints = [];
                floorMarkers.forEach(m => scene.remove(m)); floorMarkers = [];
                if(floorLine) { scene.remove(floorLine); floorLine = null; }
                if(floorLabel) { scene.remove(floorLabel); floorLabel = null; }
                document.getElementById('btn-close-floor').style.display = 'none';
                document.getElementById('inp-dist').value = "";
                document.getElementById('inp-ang').value = "";
            }

            function calculateTargetPoint() {
                const distInput = parseFloat(document.getElementById('inp-dist').value);
                const angInput = parseFloat(document.getElementById('inp-ang').value);
                if(floorPoints.length === 0) return null; 
                if(!isNaN(distInput) && distInput > 0) {
                    const lastPoint = floorPoints[floorPoints.length - 1];
                    let direction = new THREE.Vector3(1, 0, 0); 
                    if(floorPoints.length >= 2) {
                        const prevPoint = floorPoints[floorPoints.length - 2];
                        direction.subVectors(lastPoint, prevPoint).normalize();
                        if(!isNaN(angInput)) direction.applyAxisAngle(new THREE.Vector3(0, 1, 0), angInput * (Math.PI / 180));
                    }
                    return lastPoint.clone().add(direction.multiplyScalar(distInput));
                }
                return null;
            }

            function updateFloorFromInput() {
                if(!isDrawingFloor || floorPoints.length === 0) return;
                const target = calculateTargetPoint();
                if(target) updateFloorDraft(target, true);
            }

            function updateFloorDraft(currentPoint, fromInput = false) {
                if(floorPoints.length === 0) return;
                if(floorLine) scene.remove(floorLine);
                const points = [...floorPoints, currentPoint]; 
                const geo = new THREE.BufferGeometry().setFromPoints(points);
                floorLine = new THREE.Line(geo, new THREE.LineBasicMaterial({ color: 0x9b59b6, linewidth: 2 }));
                scene.add(floorLine);
                
                const lastPoint = floorPoints[floorPoints.length - 1];
                const dist = lastPoint.distanceTo(currentPoint).toFixed(2);
                let angleDeg = 0;
                if(floorPoints.length >= 2) {
                    const prevPoint = floorPoints[floorPoints.length - 2];
                    const v1 = new THREE.Vector3().subVectors(lastPoint, prevPoint).normalize();
                    const v2 = new THREE.Vector3().subVectors(currentPoint, lastPoint).normalize();
                    angleDeg = Math.round(v1.angleTo(v2) * (180 / Math.PI));
                }
                
                if(!fromInput && !isInputFocused) {
                    document.getElementById('inp-dist').value = dist;
                    document.getElementById('inp-ang').value = angleDeg;
                }

                let infoText = `${dist}m`;
                if(floorPoints.length >= 2) infoText += ` | ${angleDeg}¬∞`;
                updateFloorInfoLabel(infoText, currentPoint);
                if(floorPoints.length >= 3) document.getElementById('btn-close-floor').style.display = 'block';
            }

            function updateFloorInfoLabel(text, pos) {
                if(floorLabel) scene.remove(floorLabel);
                const canvas = document.createElement('canvas'); const ctx = canvas.getContext('2d');
                canvas.width = 300; canvas.height = 100;
                ctx.fillStyle = "rgba(0, 0, 0, 0.6)"; ctx.roundRect(10, 10, 280, 80, 15); ctx.fill();
                ctx.font = "bold 40px Arial"; ctx.fillStyle = "#fff"; ctx.textAlign = "center"; ctx.textBaseline = "middle";
                ctx.fillText(text, 150, 50);
                const mat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(canvas), depthTest: false });
                floorLabel = new THREE.Sprite(mat); floorLabel.position.copy(pos).add(new THREE.Vector3(0, 0.5, 0)); floorLabel.scale.set(3, 1, 1); floorLabel.renderOrder = 999;
                scene.add(floorLabel);
            }

            function addPointFromInput() {
                if(!isDrawingFloor) return;
                const target = calculateTargetPoint();
                if(target) {
                    addFloorPoint(target);
                    document.getElementById('inp-dist').value = "";
                    document.getElementById('inp-ang').value = "";
                    document.getElementById('inp-dist').focus();
                }
            }

            function addFloorPoint(point) {
                floorPoints.push(point);
                const mark = new THREE.Mesh(new THREE.SphereGeometry(0.1,16,16), new THREE.MeshBasicMaterial({color:0x8e44ad}));
                mark.position.copy(point); scene.add(mark); floorMarkers.push(mark);
            }

            function calculatePolygonArea(points) {
                let area = 0;
                const n = points.length;
                for (let i = 0; i < n; i++) {
                    const j = (i + 1) % n;
                    area += points[i].x * points[j].z;
                    area -= points[j].x * points[i].z;
                }
                return Math.abs(area / 2);
            }

            function finishFloor() {
                if(floorPoints.length < 3) return; 
                const area = calculatePolygonArea(floorPoints);
                const price = Math.round(area * PRICE_PER_M2);
                const shape = new THREE.Shape();
                shape.moveTo(floorPoints[0].x, floorPoints[0].z);
                for(let i = 1; i < floorPoints.length; i++) {
                    shape.lineTo(floorPoints[i].x, floorPoints[i].z);
                }
                shape.lineTo(floorPoints[0].x, floorPoints[0].z); 
                const extrudeSettings = { depth: 0.05, bevelEnabled: false }; 
                const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
                const material = new THREE.MeshStandardMaterial({ color: FLOOR_COLORS.garnet, roughness: 0.9 }); 
                const mesh = new THREE.Mesh(geometry, material);
                mesh.rotation.x = Math.PI / 2; mesh.position.y = 0; 
                mesh.receiveShadow = true; mesh.castShadow = true;
                
                mesh.userData = { price: price, locked: false, collides: true, isFloor: true, area: area.toFixed(2) };
                scene.add(mesh); objectsInScene.push(mesh); 
                totalPrice += price;
                updateBudget();
                updateFloorInfoLabel(`Area: ${area.toFixed(2)}m¬≤ (${price}‚Ç¨)`, floorPoints[floorPoints.length-1]);
                setTimeout(() => { if(!isDrawingFloor && floorLabel) scene.remove(floorLabel); }, 3000);
                clearFloorDraft();
            }

            function setFloorColor(hex) {
                if(selectedObject && selectedObject.userData.isFloor) selectedObject.material.color.setHex(hex);
            }

            // --- EVENTS ---
            function onPointerDown(event) {
                if (event.target.closest('#ui-panel') || event.target.closest('#edit-panel') || event.target.closest('#env-panel') || event.target.closest('#btn-toggle-menu') || event.target.closest('#floor-input-panel')) return;
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, activeCamera); 

                if(isDrawingFloor) {
                    if(isInputFocused) return;
                    const intersects = raycaster.intersectObjects([plane], true);
                    if(intersects.length > 0) addFloorPoint(intersects[0].point);
                    return;
                }
                if(isMeasuring) {
                    const intersects = raycaster.intersectObjects([...objectsInScene, plane], true);
                    if(intersects.length > 0) {
                        const point = intersects[0].point;
                        if(measurePoints.length === 2) clearMeasurements();
                        measurePoints.push(point); createMeasureMarker(point);
                        if(measurePoints.length === 1) document.getElementById('btn-measure').innerText = "üìè Click Punto B";
                        else if (measurePoints.length === 2) updateMeasureLine(point);
                    }
                    return;
                }
                if (productToPlace) {
                    const intersects = raycaster.intersectObject(plane);
                    if (intersects.length > 0) placeObject(intersects[0].point);
                    return;
                }
                const intersectsObjects = raycaster.intersectObjects(objectsInScene, true);
                if (intersectsObjects.length > 0) {
                    let selected = intersectsObjects[0].object;
                    while (selected.parent && !objectsInScene.includes(selected)) selected = selected.parent;
                    if (objectsInScene.includes(selected)) {
                        selectObject(selected);
                        if (!selected.userData.locked) {
                            isDragging = true; controls.enabled = false; document.body.style.cursor = 'grabbing';
                            dragStartPosition.copy(selected.position);
                        }
                    }
                } else { deselectObject(); }
            }

            function onPointerMove(event) {
                if(isInputFocused) return;
                pointer.x = (event.clientX / window.innerWidth) * 2 - 1; pointer.y = - (event.clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(pointer, activeCamera); 
                if(isDrawingFloor && floorPoints.length > 0) {
                    const intersects = raycaster.intersectObject(plane);
                    if(intersects.length > 0) updateFloorDraft(intersects[0].point);
                }
                if(isMeasuring && measurePoints.length === 1) {
                    const intersects = raycaster.intersectObjects([...objectsInScene, plane], true);
                    if(intersects.length > 0) updateMeasureLine(intersects[0].point);
                }
                if (isDragging && selectedObject && !selectedObject.userData.locked) {
                    const intersects = raycaster.intersectObject(plane);
                    if (intersects.length > 0) {
                        selectedObject.position.x = intersects[0].point.x; selectedObject.position.z = intersects[0].point.z;
                        selectionBox.update(); checkCollisions();
                    }
                }
            }

            function onPointerUp() {
                if (isDragging) {
                    if (isColliding && selectedObject.userData.collides) {
                        selectedObject.position.copy(dragStartPosition); selectionBox.update(); isColliding = false; checkCollisions();
                    }
                    isDragging = false; controls.enabled = true; document.body.style.cursor = 'default';
                }
            }

            function placeObject(pos) {
                document.getElementById('loading').style.display = 'block';
                loader.load(productToPlace, (gltf) => {
                    const model = gltf.scene;
                    model.traverse(n => { if(n.isMesh) { n.castShadow=true; n.receiveShadow=true; } });
                    model.position.set(pos.x, 0, pos.z);
                    model.userData = { price: productPrice, locked: false, collides: true };
                    scene.add(model); objectsInScene.push(model); totalPrice += productPrice; updateBudget();
                    selectObject(model); document.getElementById('loading').style.display = 'none';
                    productToPlace = null; document.querySelectorAll('.btn-product').forEach(b => b.classList.remove('active'));
                }, undefined, (err) => { console.error(err); alert("Error cargando modelo."); document.getElementById('loading').style.display = 'none'; });
            }

            function selectObject(obj) {
                selectedObject = obj; selectionBox.setFromObject(obj); selectionBox.visible = true;
                document.getElementById('edit-panel').style.display = 'block'; document.getElementById('edit-content').style.display = 'block';
                
                // SIEMPRE MOSTRAR CONTROLES EST√ÅNDAR (Posici√≥n/Rotaci√≥n)
                document.getElementById('edit-standard').style.display = 'block';

                if(obj.userData.isFloor) {
                    document.getElementById('edit-floor-specific').style.display = 'block';
                    document.getElementById('floor-price-display').innerText = obj.userData.price || 0;
                } else {
                    document.getElementById('edit-floor-specific').style.display = 'none';
                }
                updateUI();
            }
            function deselectObject() { selectedObject = null; selectionBox.visible = false; document.getElementById('edit-panel').style.display = 'none'; }
            
            function updateUI() {
                if (!selectedObject) return;
                const btnLock = document.getElementById('btn-lock'); const btnCol = document.getElementById('btn-collision');
                if (selectedObject.userData.locked) { btnLock.innerText = "üîí Desbloquear"; btnLock.classList.add('is-locked'); selectionBox.material.color.setHex(0xff4444); } 
                else { btnLock.innerText = "üîì Fijar"; btnLock.classList.remove('is-locked'); selectionBox.material.color.setHex(0xffff00); }
                if (selectedObject.userData.collides) { btnCol.innerText = "üí• Colisi√≥n: ON"; btnCol.classList.remove('is-inactive'); } 
                else { btnCol.innerText = "üëª Fantasma"; btnCol.classList.add('is-inactive'); }
            }
            function toggleLock() { if(selectedObject) { selectedObject.userData.locked = !selectedObject.userData.locked; updateUI(); } }
            function toggleObjectCollision() { if(selectedObject) { selectedObject.userData.collides = !selectedObject.userData.collides; updateUI(); } }
            function checkCollisions() {
                if (!selectedObject || !selectedObject.userData.collides) { isColliding=false; return; }
                const box = new THREE.Box3().setFromObject(selectedObject).expandByScalar(-0.1); let hit = false;
                for (let other of objectsInScene) {
                    if (other !== selectedObject && other.userData.collides) {
                        if (box.intersectsBox(new THREE.Box3().setFromObject(other).expandByScalar(-0.1))) { hit = true; break; }
                    }
                }
                isColliding = hit; selectionBox.material.color.setHex(isColliding ? 0xffa500 : 0xffff00); if (!isColliding) updateUI();
            }
            function rotateSelected(axis, deg) { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.rotation[axis] += deg * (Math.PI/180); selectionBox.update(); checkCollisions(); }
            function resetRotation() { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.rotation.set(0,0,0); if(selectedObject.userData.isFloor) selectedObject.rotation.x = Math.PI/2; selectionBox.update(); }
            function moveVertical(amount) { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.position.y += amount; selectionBox.update(); }
            function resetHeight() { if(!selectedObject || selectedObject.userData.locked) return; selectedObject.position.y = 0; selectionBox.update(); }
            function deleteSelected() { 
                if(!selectedObject || selectedObject.userData.locked) return; 
                scene.remove(selectedObject); objectsInScene.splice(objectsInScene.indexOf(selectedObject), 1);
                if(selectedObject.userData.price) totalPrice -= selectedObject.userData.price; 
                updateBudget(); deselectObject();
            }
            function resetScene() { objectsInScene.forEach(o => scene.remove(o)); objectsInScene.length=0; totalPrice=0; updateBudget(); deselectObject(); clearMeasurements(); clearFloorDraft(); }
            function updateBudget() { document.getElementById('budget-box').innerText = totalPrice.toLocaleString('es-ES') + " ‚Ç¨"; }
            
            function toggleProjection() {
                const btn = document.getElementById('btn-projection'); const prevPos = activeCamera.position.clone(); const prevTarget = controls.target.clone();
                if (activeCamera === perspectiveCamera) { activeCamera = orthoCamera; btn.innerText = "üìê Ortogr√°fica"; btn.style.background = "#555"; } 
                else { activeCamera = perspectiveCamera; btn.innerText = "üëÅÔ∏è Perspectiva"; btn.style.background = "#4a90e2"; }
                activeCamera.position.copy(prevPos); activeCamera.lookAt(prevTarget); controls.object = activeCamera; controls.update();
            }
            function setView(type) {
                controls.target.set(0,0,0);
                if(type==='iso') activeCamera.position.set(15,15,15); if(type==='top') activeCamera.position.set(0,20,0); 
                if(type==='front') activeCamera.position.set(0,0,20); if(type==='side') activeCamera.position.set(20,0,0); 
                activeCamera.lookAt(0,0,0); controls.update();
            }
            function onKeyDown(e) { if(e.key === 'Delete') deleteSelected(); }
            function onWindowResize() {
                const aspect = window.innerWidth / window.innerHeight; perspectiveCamera.aspect = aspect; perspectiveCamera.updateProjectionMatrix();
                orthoCamera.left = -20 * aspect; orthoCamera.right = 20 * aspect; orthoCamera.top = 20; orthoCamera.bottom = -20; orthoCamera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            }
            function render() {
                if (renderer.xr.isPresenting) { scene.background = null; plane.visible = false; } 
                else { if (!scene.background) { scene.background = new THREE.Color(currentEnvColor); plane.visible = true; } }
                controls.update(); renderer.render(scene, activeCamera);
            }

        } catch(e) {
            alert("Error cr√≠tico en inicializaci√≥n: " + e.message);
        }
    </script>
</body>
</html>

